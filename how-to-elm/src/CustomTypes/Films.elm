module CustomTypes.Films exposing (..)

{-| ----------------------------------------------------------------------------
    A Film (similar but different to `Songs.elm`)
    ============================================================================
    > Aim to keep your wishlist and architecture simple.
    > Have it written down somewhere, where it's easy to glance at.

    Can you write your spec in a single sentence? A page? How much detail do
    you need to know before you start coding? Can you encapsulate everything we
    need to know about the program in 1-2 Markdown pages?

        -Make the spec less dumb!-
        Remember that comments can become outdated if code changes:
        @ [v1: Previous spec](https://tinyurl.com/elm-playground-less-dumb-spec)
        @ [v2: Getting closer spec](...)

        -See the films API-
        @ `badlydrawnrob/data-playground/mocking/films`

    You find out A LOT along the way, once you start designing and building. For
    example, see "The `TimeStamp` problem" below!


    The sentence method
    -------------------
    > Using the sentence method to break down the problem!

    "You're a video man with a van full of films."
        "You need to log each film and send it to the server."
    "Each film can (optionally) hold some reviews."
        "A review can only be created if the film already exists."
    "The film can be updated but the reviews can only be deleted."
        "A film should be updated immediately, whereas reviews can be added and deleted,
    then saved to the server."
        "The video man can "lookup" reviews from a different API and copy them
        to the review form (what's the best UI for this?)."
    "Finally, expect a slow 4G connection (how do I load this quickly?)"

    Simplifying the spec
    --------------------
    > We have A LOT going on in a single page. Consider ...

    1. Make each atomic state change it's own page (`/film/:id`/ add review)
    2. Do we have minimal state and minimal data? (Reduce!)
    3. Have we narrowed the types as much as we could do?

    Assumptions
    -----------
    1. Our http server is already built with a single `/films` endpoint
    2. We output `json` with `List Film` (each film contains full reviews)
    3. Our SQL schema looks like this:

    Film                        Review
    | ID | Title      | ... |   | Timestamp  | Film ID | Name | Stars | Review |
    |----|------------|-----|   |------------|---------|------|-------|--------|
    | 1  | The Matrix | ... |   | 2023-10-01 | 1       | ...  | 5     | ...    |


    Wishlist
    --------
    > Our van is an endpoint. It starts with `[]` zero objects.
    > We're not allowed to push to the server without any `Film`s.

    We have three forms: add, edit, add review. The add form is above the
    `List Film` when it's visible. The other forms can be edited in place (within
    the `Film` it's editing)

    1. The only endpoint is `/films`. We have no individual `:id` endpoint.
        - A `Review` is implicitly tied to a `Film`.
    2. `Film` has no `Preview` state (like Elm Spa)
        - All `Film` data is loaded if it exists on the server.
        - Don't display all `Film.fields` if you need a preview view.
    3. All image URLs must be `jpeg` format and small (for fast loading)
        - Add `loading="lazy"` to the `img` tag for the view
        - @ https://web.dev/explore/fast (🚀 TIPS ON LOADING QUICKLY)
    4. A `Film` must exist before a `Review` can be made.[^1]
        - The `FilmID` is required to add a review (Elm Spa uses `/slug`)
        - Multiple reviews can be added to a film (the user is an admin)
    5. We have access to a `/reviews` API (see the films API above) to:
        - Search a review by `:id` (a bit like an ISBN number)
        - Add the review to the list (or manually create one instead)[^2]
    6. The end-user must have `Cred` (an existing logged-in account)
        - They can only peform actions (add, edit, delete, save) if logged in.
        - This type is read-only (an opaque type; generated by Auth0)
    7. Consider using `Array` or `List.take` or `List.indexedMap`
        - The latter allows us to generate an index for each list item.

    [^1]: Don't use a custom type unless you need to. We don't gain much if our
          `Review` type is a custom type (our first draft) rather than a record.

    [^2]: Avoid the `TimeStamp` problem. Reviews in the films API already have a
          timestamp. If we added that review to the reviews form, we'd need a
          hidden `"timestamp"` field. If a user then manually edits that form, for
          example to create their own review, our `TimeStamp` could get out of
          sync. Only Elm should be able to generate a `TimeStamp` (not the user).

    ----------------------------------------------------------------------------

    Paper prototyping the customer journey
    --------------------------------------
    > ⚠️ Sketch out the potential routes before you start to code

    There are so many micro-decisions to make about your program. How the user
    interacts with it, your server endpoints, how often you're pinging the server,
    how the customer journey affects state, and therefore your types.

    Reduce, reduce, reduce the possible states of your program!!!

    - Prefer minimal data wherever possible
    - What are all the possible states and how do we represent them?
    - Can we create some guarantees to make impossible states impossible?
    - Can any of these states be simplified or removed?
    - Are any of our types read-only

    Helpful videos
    --------------
    @ https://www.youtube.com/watch?v=x1FU3e0sT1I (make data structures)
    @ https://sporto.github.io/elm-patterns/basic/impossible-states.html
    @ https://elm-radio.com/episode/life-of-a-file/ (which data struture?)
    @ https://discourse.elm-lang.org/t/domain-driven-type-narrowing/7753 (narrow types)

    Elm Spa as an example (@rtfeldman)
    ----------------------------------
    1. The login page has a simple `model.form` fields setup
    2. Article uses `Status a` for `model.article` and `model.comments`
    3. Editor has a more complex `Status` type (holds every state possible)

-}

import Browser
import Html exposing (Html, button, div, h1, input, main_, text, ul, li)
import Html.Attributes exposing (placeholder, type_, value)
import Html.Events exposing (onClick, onInput)
import Http
import Iso8601
import Json.Decode as D exposing (Decoder)
import Json.Encode as E
import Process
import Random
import Task
import Time
import Url as U exposing (Url)
import Url.Builder as UB exposing (absolute, crossOrigin)

import Debug
import CustomTypes.Songs exposing (Input(..))
import Html exposing (a)


-- Model -----------------------------------------------------------------------

{-| Using a flatter model

> ⚠️ Make concrete decisions about your model and program. You can always change
> things later, but being wishy-washy can add confusion.

1. Our `Model` assumes an empty van to start `[]`
2. We simplify and reduce the data wherever we can
3. Our form inputs are just `Strings` (converted to `Film` on save)
4. We'll also assume a slow 4g connection (`LoadingSlowly`)
     - @ https://tinyurl.com/elm-spa-loading-slowly (both comments and article)


## Why not custom types?

> #! There are at least two other routes we could've taken

We're sticking to a flat model for this program. There are cleverer ways to do it,
whereby a type holds ALL the state (including the form) and all possible states
are encapsulated in a single type (used in a nested `model.form`).

As our form and `model.state` aren't bound together, we need to take care our
model doesn't get into an impossible state. Only ONE form should be visible at
any one point in time. `Add/Edit` states will share the same form fields. This is
not the best way, but it's good to have an example where we haven't fully narrowed
the types and our guarantees aren't 100%.

-}
type alias Model =
    { van : Server (Maybe (List Film)) -- #! (1)
    -- The `Film` form
    -- #! Our `json-server` provides the `String` ID
    , title : String
    , trailer : String
    , image : String
    , summary : String
    , tags : String
    -- The `Review` form
    -- #! Elm automatically generates a `TimeStamp` value.
    , name : String
    , review : String
    , rating : String
    -- The state of the form (only ONE visible at any time)
    , state: Form
    -- Any form errors we need to display
    , errors : List String
    }

init : () -> (Model, Cmd Msg)
init _ =
    ({ van : Loading
       -- The `Film` form
       , title : ""
       , trailer : ""
       , image : ""
       , summary : ""
       , tags : ""
       -- The `Review` form
       , name : ""
       , review : ""
       , rating : ""
       -- The state of the form (only ONE visible at any time)
       , state: NoForm
       -- Any form errors we need to display
       , errors : []
    }
    -- 🔄 Initial command to load films
    , Cmd.batch
        [ getFilms
        -- (2) ⏰ @rtfeldman's trick for slow loading data. This is in a `Loading`
        -- package and comes with an error message and a spinner icon ...
        -- @ https://github.com/rtfeldman/elm-spa-example/blob/master/src/Loading.elm
        , Task.perform (\_ -> PassedSlowLoadingThreshold) Process.sleep 500
    ]
    )


-- Server ----------------------------------------------------------------------

type Server a
    = Loading
    | LoadingSlowly
    | Success a
    | Error String -- Error message

-- Form ------------------------------------------------------------------------
-- Any time we've got a `Form` state we'll need to case on each branch, even if
-- we're not interested in that state in the `view` function. You can use empty
-- `text ""` values if needed.

type Form
    = NoForm
    | NewFilm
    | EditFilm FilmID
    | AddReview FilmID

{-| Narrowing the types

> Helps to make our type signatures "feel" more narrow ...

Even if it's the whole `Model` we're passing into our functions. When are these
useful? When are they superfluous?

- @ https://ckoster22.medium.com/advanced-types-in-elm-extensible-records-67e9d804030d

## Notes

> We could've used better types here ...

If we were using custom types we could've done something like:

```elm
type FilmState
    = NewFilm (List Problem) Form
    | EditFilm FilmID (List Problem) Form
    | AddReview FilmID (List Problem) Form
```

Or gotten even _more_ specific and used our `Film _ _ _` types more scope, by
including the `Form` within those `Film` type branches. This allows us to be more
specific and have more guarantees about our code base.

-}
type alias FilmForm r =
    { r
        | title : String
        , trailer : Server
        , image : String
        , summary : String
        , tags : String
    }

{-| Narrowing the types

1. `TimeStamp` should NOT be entered by the user, only set by Elm.
    - We've avoided this problem by NOT adding `/reviews/:id` API calls to the
      form fields.
2. Don't display the form until we actually need it! (Use buttons)
3. Only ONE form should be available at any one time.

-}
type alias ReviewForm r =
    { r
        | name : String
        , review : String
        , rating : String
    }


-- Film ------------------------------------------------------------------------

{-| Our Film data structures

> We're using ONE endpoint only (`/films`) unlike Elm Spa example which uses
> two endpoints (`/films/:id` and `/films/:id/comments`). We also don't distinguish
> between displays: a `Film` is always a film (see `Article Preview` and
> `Article.previewDecoder` in Elm Spa)

As this is not an opaque type (we're updating it directly, it isn't read-only) we
technically don't need `Internals` type written like this, but we'll utilise it anyway.

We could've just used a flat `type alias Record` here.

-}
type Film
    = Film Internals (Maybe (List Review)) -- #! (1) (2)

type FilmID
    = FilmID String -- #! `json-server` unfortunately stores IDs as `String`

type alias ImageID
    = String

type alias Internals =
    { id : FilmID
    , title : String
    , trailer : Maybe Url
    , summary : String
    , image : ImageID -- #! One size, eventually `-S`, `-M`, `-L`
    , tags : Maybe (List String) -- Optional (`null` allowed)
    }

filmData : Film -> Internals
filmData (Film internals _) =
    internals

decodeFilm : Decoder Film
decodeFilm =
    D.map2 Film
        decodeFilmMeta
        (D.nullable (D.list decodeReview))

decodeFilmMeta : Decoder Internals
decodeFilmMeta =
    D.map6 Internals
        (D.field "id" (D.map FilmID D.string))
        (D.field "title" D.string)
        (D.field "trailer" (D.map U.fromString D.string)) -- #! Forces a `Maybe`
        (D.field "summary" D.string)
        (D.field "image" D.string)
        (D.field "tags" (D.nullable (D.list D.string)))


-- Review ----------------------------------------------------------------------

{-| Our Review data structures

> Records are useful for different fields with the same type, or lots of
> values to be stored/accessed publically. Otherwise, consider using a
> custom type. A custom type also allows you to AVOID nested records.

The first version of this allowed a random `/reviews/:id` API to be directly added
to the review form. This had a serious potential bug, where the timestamp from
the review got added to a hidden form field (and `readonly` added to form fields).

- What if a user edited one of the form fields?
- What if a user deleted the form and started again?

Our `TimeStamp` could've gotten out of sync. So it's safer for us to save a review
from that API directly to the `List Review`. We could always allow the user to
modify it later on.

## Notes

> Do not allow any `null` values for a review! Add it or don't.

1. We'll utilize `rtfeldman/elm-iso8601-date-strings` to convert times
    - @ https://timestampgenerator.com/
2. Stars can only ever be a number between 1-5. See "Cardinality":
    - @ https://guide.elm-lang.org/appendix/types_as_sets#cardinality
    - We don't allow `.5` decimal points, and round up if a review has them.

-}
type alias Review =
    { timestamp : TimeStamp -- (1)
    , name : Name
    , review : String
    , rating : Stars -- (2)
    }

type alias TimeStamp
    = Time.Posix -- (1)

type Name
    = Name String

nameToString : Name -> String
nameToString (Name name) =
    name

{- Be strict with your `Int` types for `Stars` and avoid the "2:00" problem -}
type Stars
    = One
    | Two
    | Three
    | Four
    | Five

starsToNumber : Stars -> Int
starsToNumber star =
    case star of
        One   -> 1
        Two   -> 2
        Three -> 3
        Four  -> 4
        Five  -> 5

decodeReview : Decoder Review
decodeReview =
    D.map4 Review
        (D.field "timestamp" Iso8601.decoder) -- Handled by Elm
        (D.field "name" (D.map Name D.string)) -- Short text
        (D.field "review" D.string) -- Long text
        (D.field "stars" decodeStars)

decodeStars : Decoder Stars
decodeStars =
    let
        decodeNumber number =
            case number of
                1 -> D.succeed One
                2 -> D.succeed Two
                3 -> D.succeed Three
                4 -> D.succeed Four
                5 -> D.succeed Five
                _ -> D.fail "This is not the number you're looking for!"
    in
    D.int |> D.andThen decodeNumber


-- Http ------------------------------------------------------------------------
-- See the `data-playground/mocking/films` repo.

url : String
url = "http://localhost:3000"

getFilms : Cmd Msg
getFilms =
    Http.get
        { url = url ++ "/films"
        , expect = Http.expectJson GotFilms (D.list decodeFilm)
        }

getReview : Int -> Cmd Msg
getReview reviewID =
    Http.get
        { url = url ++ "/reviews" ++ "/" ++ String.fromInt reviewID
        , expect = Http.expectJson GotReview decodeReview
        }


-- Randomiser ------------------------------------------------------------------
-- This saves us having to manually add a review ID when using `getReview`

randomNumber : Cmd Msg
randomNumber =
    let
        oneToTen : Random.Generator Int
        oneToTen =
            Random.int 1 10
    in
    Random.generate GotNumber oneToTen




--------------------------------------------------------------------------------
-- - @ https://github.com/rtfeldman/elm-spa-example/blob/cb32acd73c3d346d0064e7923049867d8ce67193/src/Page/Login.elm#L120
--------------------------------------------------------------------------------


-- View ------------------------------------------------------------------------
-- Also consider `Html.Lazy` to lazy load the films.

{-| Our view functions

1. Add Film form is outside the `viewFilms` view.
2. Edit and Add Review are edited-in-place (within the `Film`)
3. Try to narrow the types as much as possible

-}
view : Model -> Html Msg
view model =
    case model.van of
        Loading ->
            text "Loading films..."

        LoadingSlowly ->
            text "Loading films slowly..."

        Success films ->
            main_ [] [
                h1 [] [ text "Films" ]
                , viewFilmForm model
                , viewFilms model films -- (1)
            ]

        Error errorMsg ->
            text ("Error loading films: " ++ errorMsg)


viewFilms : EditInPlace -> Maybe (List Film) -> Html Msg
viewFilms forms maybeFilms =
    case maybeFilms of
        Just films ->
            ul []
                (List.map (viewFilm forms) films)


        Nothing ->
            text "No films yet!"

viewFilmOrForm : Form -> Film -> Html Msg
viewFilmOrForm formState film =
    case formState of
        NoForm ->
            viewFilm film

        NewFilm ->
            viewFilm film

        EditFilm filmID ->
            viewFilmForm (Just film.id) (filmData film) editFilmButton

        AddReview filmID ->
            viewReviewForm filmID (filmData film) addReviewButton

{-| #! THIS NEEDS TIDYING UP: WOULD BE EASIER IF IN OWN MODULE!!! -}
viewFilm : Film -> Html Msg
viewFilm film =
    let
        data = filmData film
    in
    li []
        [ h1 [] [ text data.title ]
        , div [] [ text data.summary ]
        , case data.trailer of
            Just url ->
                a [ href (U.toString url) ] [ text "Watch trailer" ]

            Nothing ->
                text "No trailer available"
        , case data.image of
            "" ->
                text "No image available"

            imageUrl ->
                img [ src imageUrl, loading "lazy" ] []
        , case film.reviews of
            Just reviews ->
                ul [] (List.map viewReview reviews)

            Nothing ->
                text "No reviews yet!"
        ]

viewInput : String -> (String -> msg) -> String -> String -> Html msg
viewInput t p v toMsg =
  input [ type_ t, placeholder p, value v, onInput toMsg ] []

{-| ⚠️ Here's a little hacky

> Remember that our `onSubmit` state is in the FORM (not button)

Because we aren't encapsulating all form state within a `Film` or `Form` type,
we've got to do a bit of an icky `Nothing` or `Just FilmID` case in the update
function.

## Better safe than sorry ...

We could also `case formState of` and have our Add Review form within this function
also, but just to be safe we'll split that out into another function.

-}
viewFilmForm : Maybe FilmID -> FilmForm a -> Html Msg -> Html Msg
viewFilmForm maybeFilmID form button =
    form [ onSubmit (ClickedSave maybeFilmID) ] -- #! Case on this in update function
        [ viewInput "text" InputTitle "Title" form.title
        , viewInput "text" InputTrailer "Trailer URL" form.trailer
        , viewInput "text" InputImage "Image URL" form.image
        , viewInput "text" InputSummary "Summary" form.summary
        , viewInput "text" InputTags "Tags (comma separated)" form.tags
        , button
        ]

viewReviewForm : FilmID -> ReviewForm a -> Html Msg -> Html Msg
viewReviewForm filmID form button =
    form [ onSubmit (ClickedAddReview filmID) ] -- #! Case on this in update function
        [ viewInput "text" InputName "Name" form.name
        , viewInput "text" InputReview "Review" form.review
        , viewInput "text" InputRating "Rating" form.rating
        , button
        ]

addFilmButton : Html msg
addFilmButton =
    saveFilmButton "Add a new film"

editFilmButton : Html msg
editFilmButton =
    saveFilmButton "Edit the film"

addReviewButton : Html msg
addReviewButton =
    saveFilmButton "Add a review"

saveFilmButton : String -> Html msg
saveFilmButton caption =
    button [ class "button" ]
        [ text caption ]






-- Messages --------------------------------------------------------------------

type Msg
    = ClickedAddFilm -- #! If I'm sharing a `
    | ClickedRandom
    | ClickedAddReview FilmID
    | GotFilms (Result Http.Error (List Film))
    | GotNumber Int
    | GotReview (Result Http.Error Review)
    | PassedSlowLoadingThreshold
    -- Film form
    | InputTitle String
    | InputTrailer String
    | InputImage String
    | InputSummary String
    | InputTags String
    -- Review form
    | InputTimeStamp String -- Hidden (only used for reviews API)
    | InputName String
    | InputReview String
    | InputRating String


-- Update functions ------------------------------------------------------------

update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        ClickedRandom ->
            ( model, randomNumber )

        ClickedAddFilm ->
            Debug.todo "Make the film form work"

        ClickedAddReview ->
            Debug.todo "Make the review form work"

        GotFilms (Ok []) ->
            -- If our van is empty (from the server) we notify:
            ( { model
                | van = Success Nothing
              }
            , Cmd.none
            )

        GotFilms (Ok films) ->
            -- Otherwise update the model with current list of films
            ( { model
                | van = Success (Just films)
                , formReview = True -- #! Only display if there's films!
              }
            , Cmd.none
            )

        GotFilms (Err error) ->
            -- Handle the error (e.g: display an error message)
            -- #! Remember that Ai (copilot) hallucinates. There is no
            -- `Http.errorToString` function in Elm (but `Json.Decode` does!)
            ( { model
                | van = Error ("Failed to load films"  ++ Debug.toString error)
              }
            , Cmd.none )

        GotNumber number ->
            -- Use the random number to get a review
            ( model, getReview number )

        GotReview (Ok review) ->
            ( addTemporaryReview review model
            , Cmd.none
            )

        PassedSlowLoadingThreshold ->
            -- In Elm Spa it doesn't directly change to `LoadingSlowly`, but
            -- checks the state first. If `Loaded` then it does nothing.
            case model.van of
                Loading ->
                    -- If we're still loading, we can switch to LoadingSlowly
                    ( { model | van = LoadingSlowly }
                    , Cmd.none )

                _ ->
                    -- Otherwise, ignore the message: do nothing.
                    ( model, Cmd.none )

        -- Film form

        InputTitle str ->
            ( { model | title = str }
            , Cmd.none
            )

        InputTrailer str ->
            ( { model | trailer = str }
            , Cmd.none
            )

        InputImage str ->
            ( { model | image = str }
            , Cmd.none
            )

        InputSummary str ->
            ( { model | summary = str }
            , Cmd.none
            )

        InputTags str ->
            ( { model | tags = str }
            , Cmd.none
            )

        -- Review form

        InputName str ->
            ( { model | name = str }
            , Cmd.none
            )

        InputReview str ->
            ( { model | review = str }
            , Cmd.none
            )

        InputRating str ->
            ( { model | rating = str }
            , Cmd.none
            )

        -- #! Only used if pulling from the `reviews/:id` API
        InputTimeStamp str ->
            ( { model | review = str }
            , Cmd.none
            )


{-| Adding our review API result to the review form

> ⚠️ Our review form expects strings!
> ⚠️ We could've simply had an "Add Review" button (and not used the form)
> ⚠️ Or used a `Status a` type and saved to the model `Loaded Review`

I decided not to bother saving to the model and storing it temporarily. We'll
just use the values as strings (like our form). Our decoded `Review` has a
`timestamp` and `name` as custom types. This function helps us re-use our review
form when we've pinged the review API!

## The `TimeStamp` problem

> ⚠️ Our `TimeStamp` is a bit tricksy.

The end-user never need know there's a timestamp there. Elm handles that. However,
our `/reviews/:id` API already has timestamps in ISO 8601 format, so we decode
that and use it in a hidden `viewInput "text" _ "Timestamp"` field.

The problem lies in if the user manually edits the review before saving, as now
we have a ROGUE TIMESTAMP! We can either:

(a) Bipass the form completely and have a "SAVE Review" button (from API)
(b) Use `readonly` in our `viewInput` value, with a "CLEAR Form" button. That way
    there's no way for the user to edit the API review, they'll have to clear the
    form and start again.

    - @ https://www.w3schools.com/tags/att_input_readonly.asp

Alternatively, you can make sure that EVERY SINGLE FIELD is made to be user-editable
and you'll never have any clashes.
-}
addTemporaryReview : Review -> Model -> Model
addTemporaryReview review model =
    { model
      | timestamp = Iso8601.fromTime review.timestamp
      , name = nameToString review.name
      , review = review.review
      , rating = String.fromInt (starsToNumber review.rating)
    }


-- Film functions --------------------------------------------------------------
-- Add, edit, delete, save, orderBy stars total (update server right away)


-- Review functions ------------------------------------------------------------
-- Add, delete, orderBy stars (update film once you're done)
--
-- #! If `"timestamp"` field is empty, generate a timestamp
-- #! If `"timestamp"` field contains a `Review.timestamp`, use that one.
--
-- The ideal situation would be to have ZERO hidden form fields, and just generate
-- it when creating a `Film.review`.





-- View forms ------------------------------------------------------------------
-- Images: lazy load the images with `loading="lazy"`
--         How does `Html.Lazy` work? Any benefits?


-- Main ------------------------------------------------------------------------

subscriptions : Model -> Sub Msg
subscriptions _ =
  Sub.none

main : Program () Model Msg
main =
    Browser.element
        { init = init
        , update = update
        , subscriptions = subscriptions
        , view = view
        }
